#!/usr/bin/env ruby

require 'pathname'

# Path for any_white_space.rb, skip_stuff.rb, and (indirectly) fsm.rb
$:.unshift File.dirname(Pathname.new(__FILE__).realpath)

require 'any_white_space'
require 'skip_stuff' # String#without{Xml|Cpp}Comments, String#withoutCppStrings
require 'pathname'

def mlgrep(*args)
  catch(:exit) {
    files_and_dirs, normalized_args, flags, patterns, exclude_regexen, regexp_to_find =
      gather_parameters(args)
    
    anything_found = search(files_and_dirs, normalized_args, flags, patterns,
                            exclude_regexen, regexp_to_find)
   
    print_statistics regexp_to_find if flags[:statistics]
    return anything_found ? 0 : 1
  }
  1 # We end up here because of throw :exit, so it's an error.
end

def gather_parameters(args)
  args_after_options, normalized_args, flags, patterns, exclude_regexen =
    parse_args args
    
  if flags[:statistics]
    $match_statistics = Hash.new 0
    $file_statistics  = Hash.new 0
  end
    
  Doc.usage if flags[:help]
  short_usage 'No regexp was given.' if args_after_options.empty?

  # Work with duplicate of argument in case args_after_options are frozen.
  regexp_to_find = make_regex args_after_options.shift.dup, flags

  exclude_regexen << %r"\b#{regexp_to_find.source}\b" if flags[:exclude_self]
  [args_after_options.exclude(exclude_regexen), normalized_args, flags,
   patterns, exclude_regexen, regexp_to_find]
end

def search(files_and_dirs, normalized_args, flags, patterns, exclude_regexen,
           regexp_to_find)
  anything_found =
    mlgrep_search_files($stdout, regexp_to_find,
                        files_and_dirs.select { |e| File.file?(e) }.flatten.uniq,
                        flags)

  if patterns.any?
    # Search recursively for files if a pattern option was given.
    require 'find'
    dirs_to_search = files_and_dirs.select { |e| File.directory?(e) }
    dirs_to_search = ['.'] if dirs_to_search.empty?
    dirs_to_search.each { |dir|
      Find.find dir do |f|
        Find.prune if f =~ /\.snapshot/ or f =~ /~$/
        Find.prune if exclude_regexen.find { |re| f =~ re }
        
        if File.directory? f and not File.symlink? f
          f = f.realpath if flags[:absolute_paths]
          files = patterns.map { |p|
            Dir[File.join(f,p)].exclude exclude_regexen
          }
          files << hashbang_matches(normalized_args, f)
          anything_found ||= mlgrep_search_files($stdout, regexp_to_find,
                                                 files.flatten.uniq, flags)
        end
      end
    }
  elsif files_and_dirs.empty? or files_and_dirs == ['/dev/null']
    if exclude_regexen.any?
      short_usage "Exclusion flag (-x or -X) but no pattern flag " +
        "(-C,-H,-J,-L,-M,-P,-S,-r) or file list"
    end

    # If no filenames were given, mlgrep is used in pipe mode. Just print
    # the match.
    $stdin.read.multiline_grep "STDIN", :raw, regexp_to_find, flags do
      |line_nr, match|
      puts match
      anything_found = true
    end
  end
  anything_found
end

def parse_args(args)
  patterns, exclude_regexen = [], []
  simple_flags = {
    '-a' => :absolute_paths,
    '-c' => :no_comments,
    '-e' => :exclude_self,
    '-h' => :help,
    '-i' => :ignore_case,
    '-k' => :statistics,
    '-l' => :list,
    '-n' => :line,
    '-N' => :no_line_nr,
    '-o' => :only_match,
    '-s' => :no_strings,
    '-w' => :whole_word
  }

  simple_flags_regex = %r"-[#{simple_flags.keys.join.gsub '-', ''}]"

  flags = {}
  normalized_args = args.map { |arg|
    if arg =~ /^-([a-z]{2,})$/i
      # Break up compound flags, e.g., "-nsi" => "-n", "-s", "-i"
      $1.split(//).map { |x| "-#{x}" }
    else
      arg
    end
  }.flatten

  args = normalized_args.dup

  while args.first =~ /^-/
    %w(ln lN lq lo lk).each { |combo|
      opt = args.grep %r"^-[#{combo}]"
      short_usage "Can't combine #{opt * ' '}." if opt.size > 1
    }

    case args.shift
      # Files to include/exclude
    when '-C' then patterns << '*.{cc,c,cpp}'
    when '-H' then patterns << '*.{hh,h,hpp}'
    when '-J' then patterns << '*.java'
    when '-L' then patterns << '*.{pl,PL,pm,pod,t}'
    when '-M' then patterns << '{*.cmake,CMakeLists.txt}'
    when '-P' then patterns << '*.py'
    when '-R' then patterns << '*.rb'
    when '-S' then patterns << get_property('source')
    when '-r' then patterns << args.shift
    when '-x' then exclude_regexen << Regexp.new(args.shift)
    when '-X'
      re = get_property 'exclude'
      exclude_regexen << Regexp.new(re) unless re.empty?
      # Flags
    when simple_flags_regex then flags[simple_flags[$&]] = true
    when /-q(\d+)?/         then flags[:quiet] = Integer($1 || 20)
    when /.*/               then short_usage "Unknown flag: #{$&}."
    end
  end
  flags_in_args = args.grep(/^-/)
  if flags_in_args.any?
    short_usage "Flag #{flags_in_args.first} encountered after regexp"
  end
  flags.freeze
  [args, normalized_args.grep(/^-/), flags, patterns, exclude_regexen]
end

def print_statistics(regexp_to_find)
  [ $file_statistics, $match_statistics ].each { |table|
    table.sort.each { |key, count|
      key = %Q{"#{key}"} if key =~ /\s+$/
      puts "%5d %s" % [count, key]
    }
    if table.object_id == $file_statistics.object_id
      puts "-" * 50
    else
      total = table.values.inject(0) { |sum, count| sum + count }
      printf "%5d TOTAL /%s/\n", total, regexp_to_find.source
    end
  }
end

def get_property(name)
  filename = in_home_dir '.mlgreprc'
  create_default_mlgreprc unless File.exist? filename
  lines = IO.readlines(filename).grep %r"^#{name}:"
  case lines.size
  when 0 then raise "No line starting with #{name}: found in #{filename}"
  when 1 then lines.first.match(%r"([\"'])(.*)\1")[2]
  else raise "Multiple entries for property #{name} found in #{filename}"
  end
end

def create_default_mlgreprc
  File.open(in_home_dir('.mlgreprc'), 'w') { |f|
    f.puts "# Glob pattern for files to find with the -S flag."
    f.puts("source: '{*.{cc,c,cpp,hh,h,hpp,java,pl,PL,pm,pod,t,py,rb,cmake}," +
           "CMakeLists.txt}'")
    f.puts("# Regular expression for files and directories to exclude with " +
           "the -X flag.")
    f.puts "exclude: '.svn/'"
  }
end

def in_home_dir(rel_path)
  File.join(ENV['HOME'] || ENV['HOMEDRIVE'], rel_path)
end

def make_regex(re_string, flags)
  # Special regexp \u (until)
  re_string.gsub!(/\\u\[(.*?[^\\])\]/, '[^\1]*[\1]')
  re_string.gsub!(/\\u(\\?.)/, '[^\1]*\1')

  # Expressions like [^\n]* are ok in -n mode so we filter out negative REs.
  if flags[:line] and re_string.gsub(/\[\^.*?[^\\]\]/, '').index('\n')
    short_usage "Don't use \\n in regexp when in line mode (-n)"
  end

  re_string = "\\b(?:#{re_string})\\b" if flags[:whole_word]
  if flags[:line]
    re_string = '^.*' + re_string + '.*[\n$]'
    re_flags = 0
  else
    re_flags = Regexp::MULTILINE
  end
  re_flags |= Regexp::IGNORECASE if flags[:ignore_case]

  Regexp.new(re_string, re_flags).any_white_space
end

def mlgrep_search_files(output, re, names, flags = {})
  filenames = names.select { |name|
    File.file?(name) and not File.symlink?(name)
  }
  anything_found = false
  filenames.each { |filename|
    text = IO.read filename rescue text = ""
    filename = filename.realpath if flags[:absolute_paths]

    text.multiline_grep filename, :strip, re, flags do |line_nr, match|
      anything_found = true
      if flags[:statistics]
        $match_statistics[match] += 1
        $file_statistics[filename] += 1
      else
        if flags[:list]
          puts filename
          break
        end

        match = text.split(/\n/)[line_nr - 1].strip if flags[:line]
        output << "#{filename}:#{line_nr}: " unless flags[:no_line_nr]
        yield filename, line_nr, match if block_given?
        output << match << "\n"
      end
    end
  }
  anything_found
end

module Enumerable
  # Rejects all elements matching any of the given regexen.
  def exclude(regexen)
    reject { |name| regexen.find { |re| name =~ re } }
  end
end

class Doc
  def self.usage
    File.open("README").readlines.each { |line|
      puts line.sub(/^# ?/, '') unless line =~ /#!/
    }
    throw :exit
  end
end
    
def short_usage(msg)
  $stderr << msg << "\n\n" <<
    # Extract usage information (synopsis) from README file.
    IO.read("README")[%r"Usage.*?(?=-[^h]:)"m] << "\n"
  throw :exit
end

def hashbang_matches(normalized_args, dir)
  interpreters = {
    '-P' => /python/i,
    '-R' => /ruby/i,
    '-L' => /perl/i,
    '-S' => %r'perl|python|ruby|/(ba)?sh'i
  }
  matches = []
  suffixless = Dir["#{dir}/*"] - Dir["#{dir}/*.*"]
  suffixless.each { |s|
    File.open_with_error_handling(s) { |f|
      if not f.eof? and f.readline.force_encoding('ASCII-8BIT') =~ /^#!.*/
        line1 = $&
        normalized_args.each { |arg|
          matches << s if line1 =~ interpreters[arg]
        }
      end
    }
  }
  matches
end

class File
  def self.open_with_error_handling(name)
    if file? name and readable? name and not symlink? name and name !~ /~$/
      begin
        open(name) { |f| yield f }
      rescue Errno::ENXIO => e
        $stdout.puts "mlgrep: #{e}"
      end
    end
  end
end

class String
  def multiline_grep(file_name, do_strip, re, flags)
    encoding = $1 if self =~ /coding: ([\w-]+)/

    if flags[:no_comments]
      replace case file_name
              when /\.xml$/i
                withoutXmlComments
              when /\.(properties|rb|sh|pm|pl|py|cmake|mak)$/, /CMakeLists.txt/
                withoutScriptComments
              else if self =~ /\A#[!\s]/m
                     withoutScriptComments
                   else
                     withoutCppComments
                   end
              end
    end
    if flags[:no_strings]
      replace withoutCppStrings
      if file_name =~ /\.py$/ || self =~ /\A#.*ython/
        replace withoutPythonStrings
      end
    end

    pos = 0
    proper_name = {
      # These are mappings from encoding names that appear in MRI ruby source
      # code to their real names.
      'NIL' => 'ASCII-8BIT',
      'EUC' => 'EUC-JP',
      'UTF' => 'UTF-8'
    }
    loop {
      raw_text = self[pos..-1].force_encoding 'ASCII-8BIT'
      begin
        if encoding
          self[pos..-1].force_encoding proper_name[encoding.upcase] || encoding
          break unless self[pos..-1].valid_encoding?
        end
        relpos = self[pos..-1] =~ re or break
      rescue ArgumentError
        puts "Warning: #$! in #{file_name}"
        break
      end
      line  = self[0..pos+relpos].count("\n") + 1
      match = if flags[:only_match]
                "#$1 #$2 #$3 #$4 #$5 #$6 #$7 #$8 #$9".strip || $&
              else
                $&
              end
      if $&.empty?
        pos += relpos + 1 # avoid infinite loop
        break if pos >= length
      else
        match_length = $&.length
        match.gsub!(/\s+/, ' ') if do_strip == :strip
        q = flags[:quiet]
        match[q...-q] = ' ... ' if q and match.size > 2*q+5
        yield line, match
        pos += relpos + match_length
      end
    }
  end

  def realpath
    Pathname.new(self).realpath.to_s
  rescue Errno::ENOENT => e
    p e
  end

  # Dummy implementations of string encoding methods for ruby 1.8.
  unless "".respond_to? :force_encoding
    def force_encoding(name) self end
    def valid_encoding?() true end
  end
end

exit(mlgrep(*ARGV)) if $0 == __FILE__
