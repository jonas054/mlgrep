#!/usr/bin/env ruby

def in_home_dir(rel_path)
  File.join(ENV['HOME'] || ENV['HOMEDRIVE'], rel_path)
end

require 'pathname'

# Path for any_white_space.rb, skip_stuff.rb, and (indirectly) fsm.rb
$:.unshift File.dirname(Pathname.new(__FILE__).realpath)

require 'any_white_space'
require 'skip_stuff' # String#without{Xml|Cpp}Comments, String#withoutCppStrings
require 'pathname'

class Doc
  def self.usage
    File.open("README").read.each { |line|
      puts line.sub(/^# ?/, '') unless line =~ /#!/
    }
    throw :exit
  end
end
    
def short_usage(msg)
  $stderr << msg << "\n\n" <<
    # Extract usage information (synopsis) from this file.
    IO.read("README")[%r"Usage.*?(?=-[^h]:)"m] << "\n"
  throw :exit
end

class String
  # Usage: aString.match_with_line(re, file_name) { |match, line| ... }
  #        aString.match_with_line(re, file_name, true) { |match, line, pos| ... }
  def match_with_line(re, file_name, include_pos = false, only_match = false)
    pos = 0
    proper_name = {
      'NIL' => 'ASCII-8BIT',
      'EUC' => 'EUC-JP',
      'UTF' => 'UTF-8'
    }
    loop {
      raw_text = self[pos..-1].force_encoding 'ASCII-8BIT'
      begin
        if raw_text =~ /coding: ([\w-]+)/n
          self[pos..-1].force_encoding proper_name[$1.upcase] || $1
          break unless self[pos..-1].valid_encoding?
        end
        relpos = self[pos..-1] =~ re or break
      rescue ArgumentError
        puts "Warning: #$! in #{file_name}"
        break
      end
      line  = self[0..pos+relpos].count("\n") + 1
      match = only_match ? "#$1 #$2 #$3 #$4 #$5 #$6 #$7 #$8 #$9".strip || $& : $&
      if $&.empty?
        pos += 1 # avoid infinite loop
      else
        args = [match, line]
        args << (pos + relpos) if include_pos
        yield(*args) if block_given?
        pos += relpos + $&.length
      end
    }
  end

  # Dummy implementations of string encoding methods for ruby 1.8.
  unless "".respond_to? :force_encoding
    def force_encoding(name) self end
    def valid_encoding?() true end
  end
end

module Enumerable
  # Rejects all elements matching any of the given regexen.
  def exclude(regexen)
    reject { |name| regexen.find { |re| name =~ re } }
  end
end

def multiline_grep(filename, text, do_strip, re, flags)
  if flags[:no_comments]
    text = case filename
           when /\.xml$/i
             text.withoutXmlComments
           when /\.(properties|rb|sh|pm|pl|py|cmake|mak)$/, /CMakeLists.txt/
             text.withoutScriptComments
           else if text =~ /\A#[!\s]/m
                  text.withoutScriptComments
                else
                  text.withoutCppComments
                end
           end
  end
  if flags[:no_strings]
    text = text.withoutCppStrings
    if filename =~ /\.py$/ || text =~ /\A#.*ython/
      text = text.withoutPythonStrings
    end
  end

  text.match_with_line(re, filename, false,
                       flags[:only_match]) { |match, line_nr|
    match.gsub!(/\s+/, ' ') if do_strip == :strip
    q = flags[:quiet]
    match[q...-q] = ' ... ' if q and match.size > 2*q+5
    if flags[:statistics]
      $match_statistics[match] += 1
      $file_statistics[filename] += 1
    else
      yield line_nr, match
    end
  }
end

class String
  def realpath
    Pathname.new(self).realpath.to_s
  rescue Errno::ENOENT => e
    p e
  end
end

def mlgrep_search_files(output, re, names, flags = {})
  filenames = names.select { |name|
    File.file?(name) and not File.symlink?(name)
  }
  filenames.each { |filename|
    text = IO.read filename rescue text = ""
    filename = filename.realpath if flags[:absolute_paths]

    multiline_grep filename, text, :strip, re, flags do |line_nr, match|
      if flags[:list]
        $stdout << "#{filename}\n"
        break
      end

      match = text.split(/\n/)[line_nr - 1].strip if flags[:line]
      output << "#{filename}:#{line_nr}: " unless flags[:no_line_nr]
      yield filename, line_nr, match if block_given?
      output << match << "\n"
    end
  }
end

def get_property(name)
  filename = in_home_dir '.mlgreprc'
  lines = IO.readlines(filename).grep %r"^#{name}:"
  case lines.size
  when 0 then raise "No line starting with #{name}: found in #{filename}"
  when 1 then lines.first.match(%r"([\"'])(.*)\1")[2]
  else raise "Multiple entries for property #{name} found in #{filename}"
  end
end

SourcePattern = get_property 'source' # files search by -S

def make_regex(re_string, flags)
  # special regexp \u (until)
  re_string.gsub!(/\\u\[(.*?[^\\])\]/, '[^\1]*[\1]')
  re_string.gsub!(/\\u(\\?.)/, '[^\1]*\1')

  # Expressions like [^\n]* are ok in -n mode so we filter out negative REs.
  if flags[:line] and re_string.gsub(/\[\^.*?[^\\]\]/, '').index('\n')
    short_usage "Don't use \\n in regexp when in line mode (-n)"
  end

  re_string = "\\b(?:#{re_string})\\b" if flags[:whole_word]
  if flags[:line]
    re_string = '^.*' + re_string + '.*[\n$]'
    re_flags = 0
  else
    re_flags = Regexp::MULTILINE
  end
  re_flags |= Regexp::IGNORECASE if flags[:ignore_case]

  Regexp.new(re_string, re_flags).any_white_space
end

def parse_args(args)
  patterns, exclude_regexen = [], []
  simple_flags = {
    '-a' => :absolute_paths,
    '-c' => :no_comments,
    '-e' => :exclude_self,
    '-h' => :help,
    '-i' => :ignore_case,
    '-k' => :statistics,
    '-l' => :list,
    '-n' => :line,
    '-N' => :no_line_nr,
    '-o' => :only_match,
    '-s' => :no_strings,
    '-w' => :whole_word
  }

  simple_flags_regex = %r"-[#{simple_flags.keys.join.gsub '-', ''}]"

  flags = {}
  normalized_args = args.map { |arg|
    if arg =~ /^-([a-z]{2,})$/i
      # Break up compound flags, e.g., "-nsi" => "-n", "-s", "-i"
      $1.split(//).map { |x| "-#{x}" }
    else
      arg
    end
  }.flatten

  args = normalized_args.dup

  while args.first =~ /^-/
    %w(ln lN lq lo lk).each { |combo|
      opt = args.grep %r"^-[#{combo}]"
      short_usage "Can't combine #{opt * ' '}." if opt.size > 1
    }

    case args.shift
      # Files to include/exclude
    when '-C' then patterns << '*.{cc,c,cpp}'
    when '-H' then patterns << '*.{hh,h,hpp}'
    when '-J' then patterns << '*.java'
    when '-L' then patterns << '*.{pl,PL,pm,pod,t}'
    when '-M' then patterns << '{*.cmake,CMakeLists.txt}'
    when '-P' then patterns << '*.{py}'
    when '-R' then patterns << '*.rb'
    when '-S' then patterns << SourcePattern
    when '-r' then patterns << args.shift
    when '-x' then exclude_regexen << Regexp.new(args.shift)
    when '-X'
      re = get_property 'exclude'
      exclude_regexen << Regexp.new(re) unless re.empty?
      # Flags
    when simple_flags_regex then flags[simple_flags[$&]] = true
    when /-q(\d+)?/         then flags[:quiet] = Integer($1 || 20)
    when /.*/               then short_usage "Unknown flag: #{$&}."
    end
  end
  flags_in_args = args.grep(/^-/)
  if flags_in_args.any?
    short_usage "Flag #{flags_in_args.first} encountered after regexp"
  end
  flags.freeze
  [args, normalized_args.grep(/^-/), flags, patterns, exclude_regexen]
end

def print_statistics(regexp_to_find)
  [ $file_statistics, $match_statistics ].each { |table|
    table.sort.each { |key, count|
      key = %Q{"#{key}"} if key =~ /\s+$/
      puts "%5d %s" % [count, key]
    }
    if table.object_id == $file_statistics.object_id
      puts "-" * 50
    else
      total = table.values.inject(0) { |sum, count| sum + count }
      printf "%5d TOTAL /%s/\n", total, regexp_to_find.source
    end
  }
end

def mlgrep(*args)
  catch(:exit) {
    patterns, exclude_regexen = [], []
    $match_statistics = Hash.new 0
    $file_statistics = Hash.new 0
    args, normalized_args, flags, patterns, exclude_regexen = parse_args args
   
    Doc.usage if flags[:help]
    short_usage 'No regexp was given.' if args.empty?

    # Work with duplicate of argument in case args are frozen.
    regexp_to_find = make_regex args.shift.dup, flags

    exclude_regexen << %r"\b#{regexp_to_find.source}\b" if flags[:exclude_self]
   
    args = args.exclude(exclude_regexen)
    files = args.select { |e| File.file?(e) }
    if files.any?
      mlgrep_search_files($stdout, regexp_to_find, files.flatten.uniq, flags)
    end
   
    if patterns.any?
      # Search recursively for files if a pattern option was given.
      require 'find'
      dirs_to_search = args.select { |e|
        File.directory?(e)
      }
      dirs_to_search = ['.'] if dirs_to_search.empty?
      dirs_to_search.each { |dir|
        Find.find dir do |f|
          Find.prune if f =~ /\.snapshot/ or f =~ /~$/
          Find.prune if exclude_regexen.find { |re| f =~ re }
   
          if File.directory? f and not File.symlink? f
            f = f.realpath if flags[:absolute_paths]
            files = patterns.map { |p|
              Dir[File.join(f,p)].exclude exclude_regexen
            }
            files << hashbang_matches(normalized_args, f)
            mlgrep_search_files($stdout, regexp_to_find, files.flatten.uniq,
                                flags)
          end
        end
      }
    elsif args.empty? or args == ['/dev/null']
      if exclude_regexen.any?
        short_usage "Exclusion flag (-x or -X) but no pattern flag " +
          "(-C,-H,-J,-L,-M,-P,-S,-r) or file list"
      end

      # If no filenames were given, mlgrep is used in pipe mode. Just print
      # the match.
      multiline_grep "STDIN", $stdin.read, :raw, regexp_to_find, flags do
        |line_nr, match|
        puts match
      end
    end
   
    print_statistics regexp_to_find if flags[:statistics]
  }
end

def hashbang_matches(normalized_args, dir)
  interpreters = {
    '-P' => /python/i,
    '-R' => /ruby/i,
    '-L' => /perl/i,
    '-S' => %r'perl|python|ruby|/(ba)?sh'i
  }
  matches = []
  suffixless = Dir["#{dir}/*"] - Dir["#{dir}/*.*"]
  suffixless.each { |s|
    File.open_with_error_handling(s) { |f|
      if not f.eof? and f.readline.force_encoding('ASCII-8BIT') =~ /^#!.*/
        line1 = $&
        normalized_args.each { |arg|
          matches << s if line1 =~ interpreters[arg]
        }
      end
    }
  }
  matches
end

class File
  def self.open_with_error_handling(name)
    if file? name and readable? name and not symlink? name and name !~ /~$/
      begin
        open(name) { |f| yield f }
      rescue Errno::ENXIO => e
        $stdout.puts "mlgrep: #{e}"
      end
    end
  end
end

mlgrep(*ARGV) if $0 == __FILE__
